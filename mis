#!/bin/bash
# KSU Modül Yöneticisi v10.6 - Otomasyon Odaklı Sürüm
# YENİLİKLER (v10.6):
# - Hata yönetimi iyileştirildi. Artık tek bir modül hatası tüm iş akışını durdurmuyor.
# - Başarısız modüller raporlanır ancak betik 'exit 0' (başarılı) koduyla biter.
# - Bu sayede, başarılı indirilen dosyalar bir sonraki adıma (telegram_guncelle.sh) geçebilir.

# --- Yapılandırma ve Global Değişkenler ---
MODULES_FILE="" 
CACHE_DIR="$HOME/.cache/ksu-manager"
CACHE_MANIFEST="$CACHE_DIR/manifest.json"
MAX_JOBS=4

# --- Renkler ve Yardımcı Fonksiyonlar ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

info() { echo -e "${GREEN}[BİLGİ]${NC} $1"; }
warn() { echo -e "${YELLOW}[UYARI]${NC} $1"; }
# 'error' fonksiyonu artık betiği sonlandırmıyor, sadece hata mesajı basıyor.
error() { echo -e "${RED}[HATA]${NC} $1" >&2; }

# --- Betik Çıkış Kontrolü ---
cleanup() {
    if [ -n "$RESULTS_DIR" ] && [ -d "$RESULTS_DIR" ]; then rm -rf "$RESULTS_DIR"; fi
    if [ -d "$CACHE_DIR/manifest.lock" ]; then rmdir "$CACHE_DIR/manifest.lock"; fi
}
trap cleanup EXIT

# --- Çekirdek Fonksiyonlar ---
init_system() {
    for cmd in curl jq git grep sed; do if ! command -v $cmd &> /dev/null; then echo "HATA: '$cmd' bulunamadı." >&2; exit 1; fi; done
    
    if [ -f "./modules.json" ]; then
        MODULES_FILE="./modules.json"
        info "'modules.json' proje kök dizininde bulundu."
    elif [ -f "$HOME/.config/ksu-manager/modules.json" ]; then
        MODULES_FILE="$HOME/.config/ksu-manager/modules.json"
        info "'modules.json' standart yapılandırma dizininde bulundu."
    else
        echo "HATA: modules.json dosyası bulunamadı." >&2; exit 1;
    fi

    mkdir -p "$CACHE_DIR"
    if [ ! -f "$CACHE_MANIFEST" ]; then warn "'$CACHE_MANIFEST' bulunamadı, yeniden oluşturuluyor."; echo '{}' > "$CACHE_MANIFEST"; fi
}

get_api_call() {
    local url=$1; shift
    local headers=()
    if [[ "$url" == *"api.github.com"* && -n "$GIT_API_TOKEN" ]]; then
        headers=(-H "Authorization: Bearer $GIT_API_TOKEN")
    fi

    local response
    response=$(curl --silent --location --connect-timeout 15 --max-time 30 \
                   -w "\nHTTP_STATUS:%{http_code}" \
                   "${headers[@]}" "$@" "$url")
    
    local curl_exit_code=$?
    if [ $curl_exit_code -ne 0 ]; then
        echo "CURL_ERROR: Curl komutu başarısız oldu (exit code $curl_exit_code)."
        return 1
    fi

    local http_status
    http_status=$(echo "$response" | tail -n 1 | sed 's/HTTP_STATUS://')
    local content
    content=$(echo "$response" | sed '$d')

    if [[ "$http_status" -lt 200 || "$http_status" -gt 299 ]]; then
        echo "API_ERROR: HTTP $http_status. Yanıt: $content"
        return 1
    fi
    
    echo "$content"
}


# --- Güncelleme ve Kontrol Fonksiyonları ---
get_telegram_message_with_file() {
    local keyword=$1 source_channel=$2
    local api_response
    api_response=$(get_api_call "https://api.telegram.org/bot$BOT_TOKEN_FOR_ARCHIVE/getUpdates?offset=-100&limit=100")
    if [ $? -ne 0 ]; then echo "ERROR:TELEGRAM_API - $api_response"; return 1; fi
    
    echo "$api_response" | jq -r --arg cid_str "$(echo $TELEGRAM_ARCHIVE_CHANNEL | sed 's/@//')" --arg kw "$keyword" --arg sc "$source_channel" '
        .result | reverse | .[] |
        . as $update | ($update.channel_post // $update.message) |
        select(.chat.id == ($cid_str | tonumber) or .chat.username == $cid_str) |
        select(.document) |
        select(.document.file_name | test($kw; "i")) |
        select(.caption and (.caption | contains("Kaynak: @" + $sc))) |
        .document
    ' | head -n 1
}

get_remote_filename() {
    local module_json; module_json=$(jq --arg name "$1" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    local type source filter source_channel;
    type=$(jq -r '.type' <<< "$module_json"); source=$(jq -r '.source' <<< "$module_json")
    filter=$(jq -r '.asset_filter' <<< "$module_json"); source_channel=$(jq -r '.source_channel' <<< "$module_json")

    if [ -z "$type" ]; then
        echo "ERROR:MODULE_NOT_FOUND_IN_JSON"
        return 1
    fi

    local api_response filename
    case "$type" in
        "github_release")
            api_response=$(get_api_call "https://api.github.com/repos/$source/releases/latest")
            if [ $? -ne 0 ]; then echo "ERROR:GITHUB_API - $api_response"; return 1; fi
            filename=$(jq -r --arg f "$filter" '.assets[] | select(.name | test($f; "i")) | .name' <<< "$api_response" | head -n 1)
            if [ -z "$filename" ]; then echo "ERROR:NO_ASSET_FOUND"; else echo "$filename"; fi ;;
        "github_ci")
            local page_content; page_content=$(curl -sL --fail "$source")
            if [ $? -ne 0 ]; then echo "ERROR:CI_LINK_UNREACHABLE"; return 1; fi
            local direct_download_url; direct_download_url=$(echo "$page_content" | grep -o 'https://nightly.link/[^"]*\.zip' | head -n 1)
            if [ -z "$direct_download_url" ]; then echo "ERROR:CI_LINK_NOT_FOUND"; else basename "$direct_download_url"; fi ;;
        "gitlab_release")
             local encoded_source; encoded_source=$(echo "$source" | sed 's/\//%2F/g')
             api_response=$(get_api_call "https://gitlab.com/api/v4/projects/$encoded_source/releases")
             if [ $? -ne 0 ]; then echo "ERROR:GITLAB_API - $api_response"; return 1; fi
             filename=$(echo "$api_response" | jq -r --arg f "$filter" '.[0].assets.links[] | select(.name | test($f; "i")) | .name' | head -n 1)
             if [ -z "$filename" ]; then echo "ERROR:NO_ASSET_FOUND"; else echo "$filename"; fi ;;
        "telegram_forwarder")
            local doc; doc=$(get_telegram_message_with_file "$source" "$source_channel")
            if [[ $? -ne 0 || -z "$doc" ]]; then echo "ERROR:TELEGRAM_FILE_NOT_FOUND - $doc"; return 1; fi
            echo "$doc" | jq -r '.file_name' ;;
        *) echo "ERROR:UNKNOWN_TYPE";;
    esac
}

# --- İndirme ve Senkronizasyon Fonksiyonları ---
process_single_download() {
    local module_name=$1
    local remote_file; remote_file=$(get_remote_filename "$module_name")
    if [[ $? -ne 0 || "$remote_file" == "ERROR"* || -z "$remote_file" ]]; then echo "HATA: Uzak dosya adı alınamadı. Sebep: $remote_file"; return 1; fi

    local cached_file; cached_file=$(jq -r --arg mod "$module_name" '.[$mod] // ""' "$CACHE_MANIFEST")
    if [[ "$cached_file" == "$remote_file" && -f "$CACHE_DIR/$cached_file" ]]; then
        echo "OK: '$module_name' zaten güncel."
        return 0
    fi

    echo "İNDİRME: '$module_name' için yeni sürüm ($remote_file) indiriliyor..."
    local module_json; module_json=$(jq --arg name "$module_name" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    local type source source_channel download_url;
    type=$(jq -r '.type' <<< "$module_json"); source=$(jq -r '.source' <<< "$module_json")
    source_channel=$(jq -r '.source_channel' <<< "$module_json")

    local api_response
    case "$type" in
        "github_release")
            api_response=$(get_api_call "https://api.github.com/repos/$source/releases/latest")
            if [ $? -ne 0 ]; then echo "HATA: İndirme URL'si alınamadı (GitHub API). Sebep: $api_response"; return 1; fi
            download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.assets[] | select(.name == $fname) | .browser_download_url') ;;
        "github_ci")
            local page_content; page_content=$(curl -sL --fail "$source")
            if [ $? -ne 0 ]; then echo "HATA: CI sayfasına ulaşılamadı."; return 1; fi
            download_url=$(echo "$page_content" | grep -o 'https://nightly.link/[^"]*\.zip' | head -n 1) ;;
        "gitlab_release")
            local encoded_source; encoded_source=$(echo "$source" | sed 's/\//%2F/g')
            api_response=$(get_api_call "https://gitlab.com/api/v4/projects/$encoded_source/releases")
            if [ $? -ne 0 ]; then echo "HATA: İndirme URL'si alınamadı (GitLab API). Sebep: $api_response"; return 1; fi
            download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.[0].assets.links[] | select(.name == $fname) | .url' | head -n 1) ;;
        "telegram_forwarder")
            local doc; doc=$(get_telegram_message_with_file "$source" "$source_channel")
            if [ $? -ne 0 ]; then echo "HATA: Telegram dosyası alınamadı. Sebep: $doc"; return 1; fi
            local file_id; file_id=$(echo "$doc" | jq -r '.file_id')
            local file_path_json; file_path_json=$(get_api_call "https://api.telegram.org/bot$BOT_TOKEN_FOR_ARCHIVE/getFile?file_id=$file_id")
            if [ $? -ne 0 ]; then echo "HATA: Telegram dosya yolu alınamadı. Sebep: $file_path_json"; return 1; fi
            local file_path; file_path=$(echo "$file_path_json" | jq -r '.result.file_path')
            download_url="https://api.telegram.org/file/bot$BOT_TOKEN_FOR_ARCHIVE/$file_path" ;;
    esac
    if [ -z "$download_url" ]; then echo "HATA: İndirme URL'si bulunamadı."; return 1; fi

    if curl -L --fail -o "$CACHE_DIR/$remote_file" "$download_url"; then
        (
            lock_dir="$CACHE_DIR/manifest.lock"
            while ! mkdir "$lock_dir" 2>/dev/null; do sleep 1; done
            current_manifest=$(cat "$CACHE_MANIFEST")
            old_cached_file=$(echo "$current_manifest" | jq -r --arg mod "$module_name" '.[$mod] // ""')
            if [[ -n "$old_cached_file" && "$old_cached_file" != "$remote_file" && -f "$CACHE_DIR/$old_cached_file" ]]; then rm -f "$CACHE_DIR/$old_cached_file"; fi
            echo "$current_manifest" | jq --arg mod "$module_name" --arg file "$remote_file" '.[$mod] = $file' > "$CACHE_MANIFEST.tmp" && mv "$CACHE_MANIFEST.tmp" "$CACHE_MANIFEST"
            rmdir "$lock_dir"
        )
        echo "BAŞARILI: '$module_name' indirildi ve manifest güncellendi."
    else echo "HATA: İndirme başarısız oldu ($download_url)."; rm -f "$CACHE_DIR/$remote_file"; return 1; fi
}

sync_modules() {
    info "Aktif modüllerin önbellekleri senkronize ediliyor..."
    mapfile -t modules_to_sync < <(jq -r '.modules[] | select(.enabled == true) | .name' "$MODULES_FILE")
    if [ ${#modules_to_sync[@]} -eq 0 ]; then warn "Senkronize edilecek modül yok."; return; fi
    
    RESULTS_DIR=$(mktemp -d); local job_count=0
    
    for module_name in "${modules_to_sync[@]}"; do
        process_single_download "$module_name" > "$RESULTS_DIR/$module_name.result" 2>&1 &
        
        ((job_count++)); if ((job_count >= MAX_JOBS)); then wait -n; ((job_count--)); fi
    done; wait
    
    info "Senkronizasyon tamamlandı. Sonuçlar raporlanıyor..."
    echo "-----------------------------------------------------"
    for module_name in "${modules_to_sync[@]}"; do
        echo -e "${YELLOW}Modül: $module_name${NC}"
        echo "----------------"
        cat "$RESULTS_DIR/$module_name.result"
        echo
    done
    echo "-----------------------------------------------------"

    # Hata olsa bile iş akışının devam etmesi için her zaman başarılı (0) çıkış koduyla bitir.
    # Bir sonraki betik (telegram_guncelle.sh) zaten sadece başarılı indirilenleri işleyecektir.
    info "Raporlama tamamlandı. Bir sonraki adıma geçiliyor."
}

# --- Ana Fonksiyon ---
main() {
    init_system
    case $1 in
        sync) sync_modules ;;
        *) error "Geçersiz komut: $1. Bu betik sadece 'sync' komutunu destekler." && exit 1;;
    esac
}
main "$@"

