#!/bin/bash

# KSU Modül Yöneticisi v9.2 - Otomasyon Odaklı Sürüm
# Bu sürüm, interaktif komutlar olmadan sadece 'sync' işlemi için sadeleştirilmiştir.

# --- Yapılandırma ve Global Değişkenler ---
CONFIG_DIR="$HOME/.config/ksu-manager"
MODULES_FILE="$CONFIG_DIR/modules.json"
USER_CONFIG_FILE="$CONFIG_DIR/config.json"
CACHE_DIR="$HOME/.cache/ksu-manager"
CACHE_MANIFEST="$CACHE_DIR/manifest.json"
MAX_JOBS=4

# --- Renkler ve Yardımcı Fonksiyonlar ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

info() { echo -e "${GREEN}[BİLGİ]${NC} $1"; }
warn() { echo -e "${YELLOW}[UYARI]${NC} $1"; }
error() { echo -e "${RED}[HATA]${NC} $1" >&2; exit 1; }

# --- Betik Çıkış Kontrolü ---
cleanup() {
    rm -f tmp.$$.json
    if [ -d "$CACHE_DIR/manifest.lock" ]; then rmdir "$CACHE_DIR/manifest.lock"; fi
    if [ -n "$RESULTS_DIR" ] && [ -d "$RESULTS_DIR" ]; then rm -rf "$RESULTS_DIR"; fi
}
trap cleanup EXIT

# --- Çekirdek Fonksiyonlar ---
init_system() {
    for cmd in curl jq unzip git grep sed; do if ! command -v $cmd &> /dev/null; then error "'$cmd' komutu bulunamadı."; fi; done
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
    if [ ! -f "$MODULES_FILE" ]; then error "'$MODULES_FILE' bulunamadı."; fi
    # Gerekli config dosyalarını oluştur
    if [ ! -f "$USER_CONFIG_FILE" ]; then
        echo '{"github_token": "", "telegram_bot_token": "", "telegram_listener_chat_id": ""}' > "$USER_CONFIG_FILE"
    fi
     if [ ! -f "$CACHE_MANIFEST" ]; then echo '{}' > "$CACHE_MANIFEST"; fi
}

setup_github_token() {
    if [ -n "$GIT_API_TOKEN" ]; then
        jq --arg token "$GIT_API_TOKEN" '.github_token = $token' "$USER_CONFIG_FILE" > tmp.$$.json && mv tmp.$$.json "$USER_CONFIG_FILE"
        export GITHUB_TOKEN=$GIT_API_TOKEN
    fi
}

get_telegram_config() {
    # Ortam değişkenlerinden (GitHub Secrets) oku
    if [ -n "$BOT_TOKEN" ] && [ -n "$TELEGRAM_ARCHIVE_CHANNEL" ]; then
         jq --arg token "$BOT_TOKEN" --arg id "$TELEGRAM_ARCHIVE_CHANNEL" \
            '.telegram_bot_token = $token | .telegram_listener_chat_id = $id' \
            "$USER_CONFIG_FILE" > tmp.$$.json && mv tmp.$$.json "$USER_CONFIG_FILE"
    fi
    # Betik içinde kullanmak için değişkenlere ata
    TELEGRAM_BOT_TOKEN=$(jq -r '.telegram_bot_token // ""' "$USER_CONFIG_FILE")
    TELEGRAM_LISTENER_CHAT_ID=$(jq -r '.telegram_listener_chat_id // ""' "$USER_CONFIG_FILE")

    if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_LISTENER_CHAT_ID" ]; then
        error "Telegram bot token veya arşiv kanalı ID'si bulunamadı."
    fi
}

get_api_call() { curl --silent --fail --location --connect-timeout 15 --max-time 30 "$@" "$1"; }
is_valid_json() { [ -n "$1" ] && echo "$1" | jq -e . > /dev/null 2>&1; }

# --- Modül Kaynak Fonksiyonları ---
get_telegram_message_with_file() {
    local keyword=$1
    get_telegram_config
    local api_response
    api_response=$(get_api_call "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getUpdates?offset=-100&limit=100")
    if ! is_valid_json "$api_response"; then echo "ERROR:TELEGRAM_API_INVALID_RESPONSE"; return; fi
    
    echo "$api_response" | jq -r --arg chat_id "$TELEGRAM_LISTENER_CHAT_ID" --arg keyword "$keyword" '
        .result | reverse | .[] | 
        . as $update | ($update.channel_post // $update.message) |
        select(.chat.id | tostring == $chat_id or .chat.username == $chat_id) |
        select(.document) |
        select(.document.file_name | test($keyword; "i")) |
        .document
    ' | head -n 1
}

get_remote_filename() {
    local module_json; module_json=$(jq --arg name "$1" '.modules[] | select(.name == $1)' "$MODULES_FILE")
    local type source filter;
    type=$(jq -r '.type' <<< "$module_json")
    source=$(jq -r '.source' <<< "$module_json")
    filter=$(jq -r '.asset_filter' <<< "$module_json")

    case "$type" in
        "github_release")
            local api_response; api_response=$(get_api_call "https://api.github.com/repos/$source/releases/latest" -H "Authorization: Bearer $GITHUB_TOKEN")
            if ! is_valid_json "$api_response"; then echo "ERROR:GITHUB_API"; return; fi
            jq -r --arg f "$filter" '.assets[] | select(.name | test($f; "i")) | .name' <<< "$api_response" | head -n 1
            ;;
        "telegram_forwarder")
            local doc; doc=$(get_telegram_message_with_file "$source")
            if [[ -z "$doc" || "$doc" == "ERROR"* ]]; then echo "ERROR:TELEGRAM_FILE_NOT_FOUND"; return; fi
            echo "$doc" | jq -r '.file_name'
            ;;
        *) echo "ERROR:UNKNOWN_TYPE";;
    esac
}

# --- İndirme ve Senkronizasyon ---
process_single_download() {
    local module_name=$1
    local remote_file; remote_file=$(get_remote_filename "$module_name")
    if [[ "$remote_file" == "ERROR"* || -z "$remote_file" ]]; then echo "ERROR: $remote_file"; return 1; fi

    local cached_file; cached_file=$(jq -r --arg mod "$module_name" '.[$mod] // ""' "$CACHE_MANIFEST")
    if [[ "$cached_file" == "$remote_file" && -f "$CACHE_DIR/$cached_file" ]]; then
        echo -e "OK: '$module_name' güncel." >&2; return 0
    fi

    local module_json; module_json=$(jq --arg name "$module_name" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    local type source download_url;
    type=$(jq -r '.type' <<< "$module_json")
    source=$(jq -r '.source' <<< "$module_json")

    case "$type" in
        "github_release")
            local api_response; api_response=$(get_api_call "https://api.github.com/repos/$source/releases/latest" -H "Authorization: Bearer $GITHUB_TOKEN")
            download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.assets[] | select(.name == $fname) | .browser_download_url')
            ;;
        "telegram_forwarder")
            local doc; doc=$(get_telegram_message_with_file "$source")
            local file_id; file_id=$(echo "$doc" | jq -r '.file_id')
            local file_path_json; file_path_json=$(get_api_call "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getFile?file_id=$file_id")
            if ! is_valid_json "$file_path_json"; then echo "ERROR:GET_FILE_FAILED"; return 1; fi
            local file_path; file_path=$(echo "$file_path_json" | jq -r '.result.file_path')
            download_url="https://api.telegram.org/file/bot$TELEGRAM_BOT_TOKEN/$file_path"
            ;;
    esac

    if [ -z "$download_url" ]; then echo "ERROR:DOWNLOAD_URL_NOT_FOUND"; return 1; fi

    info "'$module_name' için yeni sürüm indiriliyor: $remote_file"
    if curl -L --fail -o "$CACHE_DIR/$remote_file" "$download_url"; then
        (
            lock_dir="$CACHE_DIR/manifest.lock"
            while ! mkdir "$lock_dir" 2>/dev/null; do sleep 1; done
            current_manifest=$(cat "$CACHE_MANIFEST")
            old_cached_file=$(echo "$current_manifest" | jq -r --arg mod "$module_name" '.[$mod] // ""')
            if [[ -n "$old_cached_file" && "$old_cached_file" != "$remote_file" && -f "$CACHE_DIR/$old_cached_file" ]]; then
                rm -f "$CACHE_DIR/$old_cached_file"
            fi
            echo "$current_manifest" | jq --arg mod "$module_name" --arg file "$remote_file" '.[$mod] = $file' > "$CACHE_MANIFEST.tmp" && mv "$CACHE_MANIFEST.tmp" "$CACHE_MANIFEST"
            rmdir "$lock_dir"
        )
    else
        echo "ERROR:DOWNLOAD_FAILED"; rm -f "$CACHE_DIR/$remote_file"; return 1
    fi
}

sync_modules() {
    info "Aktif modüllerin önbellekleri senkronize ediliyor..."
    mapfile -t modules_to_sync < <(jq -r '.modules[] | select(.enabled == true) | .name' "$MODULES_FILE")
    if [ ${#modules_to_sync[@]} -eq 0 ]; then warn "Senkronize edilecek modül yok."; return; fi

    RESULTS_DIR=$(mktemp -d); local job_count=0
    for module_name in "${modules_to_sync[@]}"; do
        process_single_download "$module_name" > "$RESULTS_DIR/$module_name.result" &
        ((job_count++)); if ((job_count >= MAX_JOBS)); then wait -n; ((job_count--)); fi
    done; wait
    info "Senkronizasyon tamamlandı."
}

# --- Ana Fonksiyon ---
main() {
    init_system
    setup_github_token
    
    if [ "$1" != "sync" ]; then
        error "Bu otomasyon betiği sadece 'sync' komutunu destekler."
    fi
    sync_modules
}

main "$@"
