#!/bin/bash
# KSU Modül Yöneticisi v13 - Tekrarlı Deneme ve Sağlamlık Sürümü
# YENİLİK: Telegram API'sinden dosya ararken, olası gecikmelere karşı
# 5 saniye aralıklarla 3 kez deneme mekanizması eklendi. API'den gelen
# bozuk JSON yanıtlarına karşı daha dayanıklı hale getirildi.

# --- Yapılandırma ve Global Değişkenler ---
TELEGRAM_ARCHIVE_CHANNEL="-1002542617400"
MODULES_FILE=""
CACHE_DIR="$HOME/.cache/ksu-manager"
CACHE_MANIFEST="$CACHE_DIR/manifest.json"
MAX_JOBS=4

# --- Renkler ve Yardımcı Fonksiyonlar ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

info() { echo -e "${GREEN}[BİLGİ]${NC} $1"; }
warn() { echo -e "${YELLOW}[UYARI]${NC} $1"; }
error() { echo -e "${RED}[HATA]${NC} $1" >&2; }

cleanup() {
    if [ -n "$RESULTS_DIR" ] && [ -d "$RESULTS_DIR" ]; then rm -rf "$RESULTS_DIR"; fi
    if [ -d "$CACHE_DIR/manifest.lock" ]; then rmdir "$CACHE_DIR/manifest.lock"; fi
}
trap cleanup EXIT

init_system() {
    for cmd in curl jq git grep sed; do if ! command -v $cmd &> /dev/null; then echo "HATA: '$cmd' bulunamadı." >&2; exit 1; fi; done
    if [ -f "./modules.json" ]; then
        MODULES_FILE="./modules.json"
    elif [ -f "$HOME/.config/ksu-manager/modules.json" ]; then
        MODULES_FILE="$HOME/.config/ksu-manager/modules.json"
    else
        echo "HATA: modules.json dosyası bulunamadı." >&2; exit 1;
    fi
    mkdir -p "$CACHE_DIR"
    if [ ! -f "$CACHE_MANIFEST" ]; then warn "'$CACHE_MANIFEST' bulunamadı, yeniden oluşturuluyor."; echo '{}' > "$CACHE_MANIFEST"; fi
}

get_api_call() {
    local url=$1; shift
    local headers=()
    if [[ "$url" == *"api.github.com"* ]]; then
        if [ -z "$GIT_API_TOKEN" ]; then echo "API_ERROR: GIT_API_TOKEN sırrı ayarlanmamış."; return 1; fi
        headers=(-H "Authorization: Bearer $GIT_API_TOKEN")
    fi
    local response
    response=$(curl --silent --location --connect-timeout 15 --max-time 30 -w "\nHTTP_STATUS:%{http_code}" "${headers[@]}" "$@" "$url")
    local curl_exit_code=$?
    if [ $curl_exit_code -ne 0 ]; then echo "CURL_ERROR: Curl komutu başarısız oldu (exit code $curl_exit_code)."; return 1; fi
    local http_status content
    http_status=$(echo "$response" | tail -n 1 | sed 's/HTTP_STATUS://')
    content=$(echo "$response" | sed '$d')
    if [[ "$http_status" -lt 200 || "$http_status" -gt 299 ]]; then
        local error_msg="API_ERROR: HTTP $http_status."
        case "$http_status" in
            401) error_msg+=" Yetkilendirme hatası (Kullanılan Token geçersiz veya yetkisi yok)." ;;
            403) error_msg+=" Erişim engellendi (İzinler yetersiz veya API rate limit'e takıldı)." ;;
            404) error_msg+=" Bulunamadı (URL, depo adı veya kullanıcı adı yanlış olabilir)." ;;
        esac
        echo -e "$error_msg\nDetay: $content"; return 1;
    fi
    echo "$content"
}

get_telegram_message_with_file() {
    local keyword=$1 source_channel=$2
    local attempts=3
    
    for (( i=1; i<=attempts; i++ )); do
        local api_response
        api_response=$(get_api_call "https://api.telegram.org/bot$BOT_TOKEN_FOR_ARCHIVE/getUpdates?offset=-100&limit=100")
        if [ $? -ne 0 ]; then echo "ERROR:TELEGRAM_API - $api_response"; return 1; fi

        if ! jq -e . >/dev/null 2>&1 <<< "$api_response"; then
            if (( i < attempts )); then
                warn "Telegram API'sinden bozuk yanıt alındı ($i. deneme), 5sn sonra tekrar denenecek..."
                sleep 5
                continue
            else
                echo "ERROR:TELEGRAM_INVALID_JSON - API yanıtı geçerli JSON değil: $api_response"; return 1;
            fi
        fi

        local doc
        doc=$(echo "$api_response" | jq -r --arg cid_str "$TELEGRAM_ARCHIVE_CHANNEL" --arg kw "$keyword" --arg sc "$source_channel" '
            .result | reverse | .[] |
            . as $update | ($update.channel_post // $update.message) |
            select(.chat.id == ($cid_str | tonumber)) |
            select(.document) |
            select(.document.file_name | test($kw; "i")) |
            select(.caption and (.caption | contains("Kaynak: @" + $sc))) |
            .document
        ' | head -n 1)

        if [[ -n "$doc" && "$doc" != "null" ]]; then
            echo "$doc"
            return 0
        fi

        if (( i < attempts )); then
            warn "Arşivde dosya bulunamadı ($i. deneme), API gecikmesi olabilir, 5sn sonra tekrar denenecek..."
            sleep 5
        fi
    done
    
    echo "ERROR:FILE_NOT_FOUND_IN_ARCHIVE"
    return 1
}

get_remote_filename() {
    local module_json; module_json=$(jq --arg name "$1" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    local type source filter source_channel;
    type=$(jq -r '.type' <<< "$module_json"); source=$(jq -r '.source' <<< "$module_json")
    filter=$(jq -r '.asset_filter' <<< "$module_json"); source_channel=$(jq -r '.source_channel' <<< "$module_json")
    if [ -z "$type" ]; then echo "ERROR:MODULE_NOT_FOUND_IN_JSON"; return 1; fi
    
    local api_response filename
    case "$type" in
        "github_release")
            api_response=$(get_api_call "https://api.github.com/repos/$source/releases/latest")
            if [ $? -ne 0 ]; then echo "ERROR:GITHUB_API - $api_response"; return 1; fi
            filename=$(jq -r --arg f "$filter" '.assets[] | select(.name | test($f; "i")) | .name' <<< "$api_response" | head -n 1)
            if [ -z "$filename" ]; then echo "ERROR:NO_ASSET_FOUND - '$filter' filtresiyle eşleşen dosya bulunamadı."; else echo "$filename"; fi ;;
        "github_ci")
            local page_content; page_content=$(curl -sL --fail "$source")
            if [ $? -ne 0 ]; then echo "ERROR:CI_LINK_UNREACHABLE - '$source' adresine ulaşılamadı."; return 1; fi
            local direct_download_url; direct_download_url=$(echo "$page_content" | grep -o 'https://nightly.link/[^"]*\.zip' | head -n 1)
            if [ -z "$direct_download_url" ]; then echo "ERROR:CI_LINK_NOT_FOUND - Sayfa içinde indirme linki bulunamadı."; else basename "$direct_download_url"; fi ;;
        "gitlab_release")
             local encoded_source; encoded_source=$(echo "$source" | sed 's/\//%2F/g')
             api_response=$(get_api_call "https://gitlab.com/api/v4/projects/$encoded_source/releases")
             if [ $? -ne 0 ]; then echo "ERROR:GITLAB_API - $api_response"; return 1; fi
             filename=$(echo "$api_response" | jq -r --arg f "$filter" '.[0].assets.links[] | select(.name | test($f; "i")) | .name' | head -n 1)
             if [ -z "$filename" ]; then echo "ERROR:NO_ASSET_FOUND"; else echo "$filename"; fi ;;
        "telegram_forwarder")
            local doc; doc=$(get_telegram_message_with_file "$source" "$source_channel")
            if [[ $? -ne 0 ]]; then echo "ERROR:TELEGRAM_FILE_NOT_FOUND - Sebep: Arşiv kanalında '$source' anahtar kelimesi ve '@$source_channel' kaynağı ile eşleşen dosya, 3 deneme sonunda bulunamadı."; return 1; fi
            echo "$doc" | jq -r '.file_name' ;;
        *) echo "ERROR:UNKNOWN_TYPE - Modül tipi bilinmiyor: '$type'";;
    esac
}

process_single_download() {
    local module_name=$1
    local remote_file; remote_file=$(get_remote_filename "$module_name")
    if [[ $? -ne 0 || "$remote_file" == "ERROR"* || -z "$remote_file" ]]; then echo "HATA: Uzak dosya adı alınamadı. Sebep: $remote_file"; return 1; fi
    
    local cached_file; cached_file=$(jq -r --arg mod "$module_name" '.[$mod] // ""' "$CACHE_MANIFEST")
    if [[ "$cached_file" == "$remote_file" && -f "$CACHE_DIR/$cached_file" ]]; then echo "OK: '$module_name' zaten güncel."; return 0; fi
    
    echo "İNDİRME: '$module_name' için yeni sürüm ($remote_file) indiriliyor..."
    local module_json; module_json=$(jq --arg name "$module_name" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    local type source source_channel download_url;
    type=$(jq -r '.type' <<< "$module_json"); source=$(jq -r '.source' <<< "$module_json")
    source_channel=$(jq -r '.source_channel' <<< "$module_json")
    local api_response
    case "$type" in
        "github_release")
            api_response=$(get_api_call "https://api.github.com/repos/$source/releases/latest")
            if [ $? -ne 0 ]; then echo "HATA: İndirme URL'si alınamadı (GitHub API). Sebep: $api_response"; return 1; fi
            download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.assets[] | select(.name == $fname) | .browser_download_url') ;;
        "github_ci")
            local page_content; page_content=$(curl -sL --fail "$source")
            if [ $? -ne 0 ]; then echo "HATA: CI sayfasına ulaşılamadı."; return 1; fi
            download_url=$(echo "$page_content" | grep -o 'https://nightly.link/[^"]*\.zip' | head -n 1) ;;
        "gitlab_release")
            local encoded_source; encoded_source=$(echo "$source" | sed 's/\//%2F/g')
            api_response=$(get_api_call "https://gitlab.com/api/v4/projects/$encoded_source/releases")
            if [ $? -ne 0 ]; then echo "HATA: İndirme URL'si alınamadı (GitLab API). Sebep: $api_response"; return 1; fi
            download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.[0].assets.links[] | select(.name == $fname) | .url' | head -n 1) ;;
        "telegram_forwarder")
            local doc; doc=$(get_telegram_message_with_file "$source" "$source_channel")
            if [ $? -ne 0 ]; then echo "HATA: Telegram dosyası alınamadı. Sebep: $doc"; return 1; fi
            local file_id; file_id=$(echo "$doc" | jq -r '.file_id')
            local file_path_json; file_path_json=$(get_api_call "https://api.telegram.org/bot$BOT_TOKEN_FOR_ARCHIVE/getFile?file_id=$file_id")
            if [ $? -ne 0 ]; then echo "HATA: Telegram dosya yolu alınamadı. Sebep: $file_path_json"; return 1; fi
            local file_path; file_path=$(echo "$file_path_json" | jq -r '.result.file_path')
            download_url="https://api.telegram.org/file/bot$BOT_TOKEN_FOR_ARCHIVE/$file_path" ;;
    esac

    if [ -z "$download_url" ]; then echo "HATA: İndirme URL'si bulunamadı."; return 1; fi

    if curl -L --fail -o "$CACHE_DIR/$remote_file" "$download_url"; then
        (
            lock_dir="$CACHE_DIR/manifest.lock"
            while ! mkdir "$lock_dir" 2>/dev/null; do sleep 1; done
            current_manifest=$(cat "$CACHE_MANIFEST")
            old_cached_file=$(echo "$current_manifest" | jq -r --arg mod "$module_name" '.[$mod] // ""')
            if [[ -n "$old_cached_file" && "$old_cached_file" != "$remote_file" && -f "$CACHE_DIR/$old_cached_file" ]]; then rm -f "$CACHE_DIR/$old_cached_file"; fi
            echo "$current_manifest" | jq --arg mod "$module_name" --arg file "$remote_file" '.[$mod] = $file' > "$CACHE_MANIFEST.tmp" && mv "$CACHE_MANIFEST.tmp" "$CACHE_MANIFEST"
            rmdir "$lock_dir"
        )
        echo "BAŞARILI: '$module_name' indirildi ve manifest güncellendi."
    else echo "HATA: İndirme başarısız oldu ($download_url)."; rm -f "$CACHE_DIR/$remote_file"; return 1; fi
}

sync_modules() {
    info "Aktif modüllerin önbellekleri senkronize ediliyor..."
    mapfile -t modules_to_sync < <(jq -r '.modules[] | select(.enabled == true) | .name' "$MODULES_FILE")
    if [ ${#modules_to_sync[@]} -eq 0 ]; then warn "Senkronize edilecek modül yok."; return; fi
    RESULTS_DIR=$(mktemp -d); local job_count=0
    for module_name in "${modules_to_sync[@]}"; do
        process_single_download "$module_name" > "$RESULTS_DIR/$module_name.result" 2>&1 &
        ((job_count++)); if ((job_count >= MAX_JOBS)); then wait -n; ((job_count--)); fi
    done; wait
    info "Senkronizasyon tamamlandı. Sonuçlar raporlanıyor..."
    echo "-----------------------------------------------------"
    for module_name in "${modules_to_sync[@]}"; do
        echo -e "${YELLOW}Modül: $module_name${NC}"
        echo "----------------"
        cat "$RESULTS_DIR/$module_name.result"
        echo
    done
    echo "-----------------------------------------------------"
    info "Raporlama tamamlandı. Bir sonraki adıma geçiliyor."
}

main() {
    init_system
    case $1 in
        sync) sync_modules ;;
        *) error "Geçersiz komut: $1. Bu betik sadece 'sync' komutunu destekler." && exit 1;;
    esac
}
main "$@"

