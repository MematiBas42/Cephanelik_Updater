#!/bin/bash

# KSU Modül Yöneticisi v8.3 - Otomasyon Odaklı Sürüm
# DEĞİŞİKLİKLER (v8.3):
# - YARIŞ DURUMU (RACE CONDITION) DÜZELTMESİ: Paralel indirmeler sırasında birden fazla işlemin
#   aynı anda manifest.json dosyasına yazmaya çalışarak dosyayı bozması engellendi.
#   Dosya yazma işlemleri artık bir kilit mekanizması ile sıraya konularak güvenli hale getirildi.

# --- Yapılandırma ve Global Değişkenler ---
CONFIG_DIR="$HOME/.config/ksu-manager"
MODULES_FILE="$CONFIG_DIR/modules.json"
USER_CONFIG_FILE="$CONFIG_DIR/config.json"
CACHE_DIR="$HOME/.cache/ksu-manager"
CACHE_MANIFEST="$CACHE_DIR/manifest.json"
MAX_JOBS=3

# --- Renkler ve Yardımcı Fonksiyonlar ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

info() { echo -e "${GREEN}[BİLGİ]${NC} $1"; }
warn() { echo -e "${YELLOW}[UYARI]${NC} $1"; }
error() { echo -e "${RED}[HATA]${NC} $1" >&2; exit 1; }
prompt() { echo -e -n "${BLUE}[SORU]${NC} $1"; }

# --- Betik Çıkış Kontrolü ---
cleanup() {
    rm -f tmp.$$.json
    # Kilit kalmışsa temizle
    if [ -d "$CACHE_DIR/manifest.lock" ]; then
        rmdir "$CACHE_DIR/manifest.lock"
    fi
    if [ -n "$RESULTS_DIR" ] && [ -d "$RESULTS_DIR" ]; then
        rm -rf "$RESULTS_DIR"
    fi
}
trap cleanup EXIT

# --- Çekirdek Fonksiyonlar ---

show_help() {
    echo "KSU Modül Yöneticisi (Otomasyon Sürümü)"
    echo "-------------------------------------"
    echo "Kullanım: mis <komut> [argüman]"
    echo
    echo "Komutlar:"
    echo "  add           İnteraktif olarak yeni bir modül ekler."
    echo "  remove        Listeden bir veya daha fazla modülü kaldırır."
    echo "  toggle        Bir veya daha fazla modülü etkinleştirir/devre dışı bırakır."
    echo "  list          Yapılandırılmış tüm modülleri ve durumlarını listeler."
    echo "  sync          Tüm aktif modüllerin önbelleğini en son sürümlerle günceller."
    echo "  check <modül> Belirtilen modül için indirme linkini bulur ve gösterir."
    echo "  check-all     Tüm modüller için güncellemeleri kontrol eder ve raporlar."
    echo "  clear-cache   İndirilen modül dosyalarının bulunduğu önbelleği temizler."
    echo "  help          Bu yardım menüsünü gösterir."
}

validate_json_file() {
    if ! jq -e . "$1" > /dev/null 2>&1; then error "Yapılandırma dosyası ($1) geçersiz bir JSON formatına sahip."; fi
}

init_system() {
    for cmd in curl jq unzip git grep sed; do if ! command -v $cmd &> /dev/null; then error "'$cmd' komutu bulunamadı. Lütfen sisteminize kurun."; fi; done
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
    if [ ! -f "$MODULES_FILE" ]; then warn "'$MODULES_FILE' bulunamadı."; echo '{"modules": []}' > "$MODULES_FILE"; fi
    if [ ! -f "$USER_CONFIG_FILE" ]; then warn "'$USER_CONFIG_FILE' bulunamadı."; echo '{}' > "$USER_CONFIG_FILE"; fi
    if [ ! -f "$CACHE_MANIFEST" ]; then warn "'$CACHE_MANIFEST' bulunamadı."; echo '{}' > "$CACHE_MANIFEST"; fi
    validate_json_file "$MODULES_FILE"
    validate_json_file "$CACHE_MANIFEST"
}

setup_github_token() {
    if [ -n "$GITHUB_TOKEN" ]; then return; fi
    local token; token=$(jq -r '.github_token // ""' "$USER_CONFIG_FILE")
    if [ -n "$token" ]; then export GITHUB_TOKEN=$token; return; fi
    warn "GitHub API limitlerine takılmamak için bir Kişisel Erişim Jetonu girmeniz önerilir."
    prompt "GitHub jetonunuzu girin (veya boş bırakmak için Enter'a basın): "; read -rs GITHUB_TOKEN_INPUT; echo
    if [ -n "$GITHUB_TOKEN_INPUT" ]; then
        export GITHUB_TOKEN=$GITHUB_TOKEN_INPUT
        if [[ "$(prompt "Bu jetonu ileride kullanmak üzere kaydetmek ister misiniz? (e/h): "; read -r r; echo "$r")" =~ ^[eE]$ ]]; then
            jq --arg token "$GITHUB_TOKEN_INPUT" '.github_token = $token' "$USER_CONFIG_FILE" > tmp.$$.json && mv tmp.$$.json "$USER_CONFIG_FILE"
            info "Jeton '$USER_CONFIG_FILE' dosyasına kaydedildi."
        fi
    else warn "Jeton girilmedi. API limitlerine takılabilirsiniz."; fi
}

get_github_api() {
    local url=$1; local headers=()
    if [ -n "$GITHUB_TOKEN" ]; then headers=(-H "Authorization: Bearer $GITHUB_TOKEN"); fi
    curl --silent --fail --location --connect-timeout 10 --max-time 15 "${headers[@]}" "$url"
}

get_gitlab_api() {
    local url=$1
    curl --silent --fail --location --connect-timeout 10 --max-time 15 "$url"
}

is_valid_json() { [ -n "$1" ] && echo "$1" | jq -e . > /dev/null 2>&1; }

# --- Modül Yönetim Fonksiyonları ---

add_module() {
    info "Yeni Modül Ekleme Sihirbazı"
    prompt "Modül için bir isim girin (Örn: ZygiskNext): "; read -r name
    if [[ -z "$name" ]]; then error "Modül ismi boş olamaz."; fi
    prompt "Modül türünü seçin [1] GitHub Release [2] GitHub Actions (CI) [3] GitLab Release: "; read -r type_choice
    local owner repo type source asset_filter
    if [[ "$type_choice" == "1" ]]; then
        type="github_release"
        prompt "GitHub repo adresini girin (örn: Dr-TSNG/ZygiskNext): "; read -r source
        source=$(echo "$source" | sed -e 's|https://github.com/||' -e 's|/$||')
        prompt "Dosya adında aranacak bir desen (Regex) girin (örn: arm64.*zip$, \\.zip$ için boş bırakılabilir): "; read -r asset_filter
        asset_filter=${asset_filter:-"\\.zip$"}
    elif [[ "$type_choice" == "2" ]]; then
        type="github_ci"
        prompt "GitHub repo adresini girin (örn: KOWX712/PlayIntegrityFix): "; read -r repo_full
        repo_full=$(echo "$repo_full" | sed -e 's|https://github.com/||' -e 's|/$||')
        owner=$(echo "$repo_full" | cut -d'/' -f1); repo=$(echo "$repo_full" | cut -d'/' -f2)
        info "Dal bilgileri alınıyor..."; api_response=$(get_github_api "https://api.github.com/repos/$owner/$repo/branches")
        if ! is_valid_json "$api_response"; then error "GitHub API'sinden dal bilgileri alınamadı."; fi
        mapfile -t branches < <(echo "$api_response" | jq -r '.[].name'); echo "Bulunan dallar:"; select branch in "${branches[@]}"; do [[ -n "$branch" ]] && break; done
        if [[ -z "$branch" ]]; then error "Dal seçimi yapılmadı."; fi
        info "Workflow bilgileri alınıyor..."; api_response=$(get_github_api "https://api.github.com/repos/$owner/$repo/actions/workflows")
        if ! is_valid_json "$api_response"; then error "GitHub API'sinden workflow bilgileri alınamadı."; fi
        mapfile -t workflows < <(echo "$api_response" | jq -r '.workflows[] | select(.state == "active") | .name'); echo "Bulunan workflow'lar:"; select workflow in "${workflows[@]}"; do [[ -n "$workflow" ]] && break; done
        if [[ -z "$workflow" ]]; then error "Workflow seçimi yapılmadı."; fi
        workflow_file=$(echo "$api_response" | jq -r --arg name "$workflow" '.workflows[] | select(.name == $name) | .path' | cut -d'/' -f3)
        source="https://nightly.link/$owner/$repo/workflows/$workflow_file/$branch"; asset_filter="\\.zip$"
    elif [[ "$type_choice" == "3" ]]; then
        type="gitlab_release"
        prompt "GitLab repo adresini girin (örn: cuynu/gphotos-unlimited-zygisk): "; read -r source
        source=$(echo "$source" | sed -e 's|https://gitlab.com/||' -e 's|/-.*||' -e 's|/$||')
        prompt "Dosya adında aranacak bir desen (Regex) girin (örn: arm64.*zip$, \\.zip$ için boş bırakılabilir): "; read -r asset_filter
        asset_filter=${asset_filter:-"\\.zip$"}
    else error "Geçersiz seçim."; fi
    local new_module; new_module=$(jq -n --arg n "$name" --arg t "$type" --arg s "$source" --arg f "$asset_filter" '{name: $n, enabled: true, type: $t, source: $s, asset_filter: $f}')
    jq --argjson new "$new_module" '.modules += [$new]' "$MODULES_FILE" > tmp.$$.json && mv tmp.$$.json "$MODULES_FILE"
    info "'$name' modülü yapılandırmaya başarıyla eklendi."
}

remove_module() {
    mapfile -t modules < <(jq -r '.modules[].name' "$MODULES_FILE")
    if [ ${#modules[@]} -eq 0 ]; then warn "Kaldırılacak modül bulunamadı."; return; fi
    info "Mevcut Modüller:"; for i in "${!modules[@]}"; do echo "  $((i+1))) ${modules[$i]}"; done
    prompt "Kaldırmak istediğiniz modül(ler)in numarasını girin (örn: 1 3 5): "; read -r -a selections
    if [ ${#selections[@]} -eq 0 ]; then warn "Hiçbir seçim yapılmadı."; return; fi
    local mods_to_remove=(); for sel in "${selections[@]}"; do if [[ "$sel" =~ ^[0-9]+$ && "$sel" -gt 0 && "$sel" -le ${#modules[@]} ]]; then mods_to_remove+=("${modules[$((sel-1))]}"); else warn "Geçersiz numara: '$sel'."; fi; done
    if [ ${#mods_to_remove[@]} -eq 0 ]; then warn "Geçerli bir modül seçilmedi."; return; fi
    local condition=""; for mod_name in "${mods_to_remove[@]}"; do [ -n "$condition" ] && condition+=" or "; condition+=".name == \"$mod_name\""; done
    jq "del(.modules[] | select($condition))" "$MODULES_FILE" > tmp.$$.json && mv tmp.$$.json "$MODULES_FILE"
    local temp_manifest; temp_manifest=$(cat "$CACHE_MANIFEST")
    for mod_name in "${mods_to_remove[@]}"; do temp_manifest=$(echo "$temp_manifest" | jq "del(.\"$mod_name\")"); done
    echo "$temp_manifest" > "$CACHE_MANIFEST"
    info "Seçilen modüller başarıyla kaldırıldı: ${mods_to_remove[*]}"
}

toggle_module() {
    mapfile -t modules < <(jq -r '.modules[].name' "$MODULES_FILE")
    if [ ${#modules[@]} -eq 0 ]; then warn "Değiştirilecek modül bulunamadı."; return; fi
    info "Mevcut Modüller:"; for i in "${!modules[@]}"; do local status; status=$(jq -r --arg name "${modules[$i]}" '.modules[] | select(.name == $name) | .enabled' "$MODULES_FILE"); if [ "$status" == "true" ]; then echo -e "  $((i+1))) ${GREEN}[ON]${NC} ${modules[$i]}"; else echo -e "  $((i+1))) ${RED}[OFF]${NC} ${modules[$i]}"; fi; done
    prompt "Durumunu değiştirmek istediğiniz modül(ler)in numarasını girin (örn: 1 3 5): "; read -r -a selections
    if [ ${#selections[@]} -eq 0 ]; then warn "Hiçbir seçim yapılmadı."; return; fi
    for sel in "${selections[@]}"; do
        if ! [[ "$sel" =~ ^[0-9]+$ && "$sel" -gt 0 && "$sel" -le ${#modules[@]} ]]; then warn "Geçersiz numara: '$sel'."; continue; fi
        local mod_name="${modules[$((sel-1))]}"; local current_status; current_status=$(jq --arg name "$mod_name" -r '.modules[] | select(.name == $name) | .enabled' "$MODULES_FILE")
        local new_status=$([ "$current_status" == "true" ] && echo "false" || echo "true")
        jq --arg name "$mod_name" --argjson status "$new_status" '(.modules[] | select(.name == $name)).enabled = $status' "$MODULES_FILE" > tmp.$$.json && mv tmp.$$.json "$MODULES_FILE"
        info "'$mod_name' modülü şimdi $([ "$new_status" == "true" ] && echo -e "${GREEN}AKTİF${NC}" || echo -e "${RED}DEVRE DIŞI${NC}")."
    done
}

list_modules() {
    info "Yapılandırılmış Modüller:"
    local module_count; module_count=$(jq '.modules | length' "$MODULES_FILE")
    if [ "$module_count" -eq 0 ]; then warn "Listelenecek modül bulunamadı."; return; fi
    mapfile -t names < <(jq -r '.modules[].name' "$MODULES_FILE"); mapfile -t types < <(jq -r '.modules[].type' "$MODULES_FILE"); mapfile -t enabled_states < <(jq -r '.modules[].enabled' "$MODULES_FILE")
    local max_len=0; for name in "${names[@]}"; do (( ${#name} > max_len )) && max_len=${#name}; done; ((max_len < 10)) && max_len=10
    printf "  ${BLUE}%-5s %-${max_len}s    %s${NC}\n" "DURUM" "MODÜL ADI" "TÜR"; printf "  %.s" $(seq 1 $(($max_len + 23))) | tr ' ' '─'; echo
    for i in "${!names[@]}"; do local status_str status_color; if [[ "${enabled_states[$i]}" == "true" ]]; then status_str="[ON]"; status_color="$GREEN"; else status_str="[OFF]"; status_color="$RED"; fi; printf "  ${status_color}%-5s${NC} %-${max_len}s | %s\n" "$status_str" "${names[$i]}" "${types[$i]}"; done
}

clear_cache() {
    prompt "Önbellek dizinindeki ($CACHE_DIR) tüm dosyalar silinecek. Emin misiniz? (e/h): "; read -r choice
    if [[ "$choice" =~ ^[eE]$ ]]; then
        info "Önbellek temizleniyor..."
        rm -rf "${CACHE_DIR:?}"/*
        echo '{}' > "$CACHE_MANIFEST"
        info "Önbellek başarıyla temizlendi."
    else
        info "İşlem iptal edildi."
    fi
}

# --- Güncelleme ve Kontrol Fonksiyonları ---

get_remote_filename() {
    local module_name=$1
    local module_json; module_json=$(jq --arg name "$module_name" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    if [ -z "$module_json" ]; then echo "ERROR:NOT_FOUND_IN_JSON"; return; fi
    local type; type=$(jq -r '.type' <<< "$module_json")
    local source; source=$(jq -r '.source' <<< "$module_json")
    local filter; filter=$(jq -r '.asset_filter' <<< "$module_json")

    if [ "$type" == "github_release" ]; then
        local owner repo; owner=$(echo "$source" | cut -d'/' -f1); repo=$(echo "$source" | cut -d'/' -f2)
        local api_response; api_response=$(get_github_api "https://api.github.com/repos/$owner/$repo/releases/latest")
        if ! is_valid_json "$api_response"; then echo "ERROR:API_INVALID_RESPONSE"; return; fi
        local matching_filename; matching_filename=$(echo "$api_response" | jq -r --arg filter "$filter" '.assets[] | select(.name | test($filter; "i")) | .name' | head -n 1)
        if [ -z "$matching_filename" ]; then echo "ERROR:NO_ASSET_FOUND"; else echo "$matching_filename"; fi
    elif [ "$type" == "gitlab_release" ]; then
        local encoded_source; encoded_source=$(echo "$source" | sed 's/\//%2F/g')
        local api_response; api_response=$(get_gitlab_api "https://gitlab.com/api/v4/projects/$encoded_source/releases")
        if ! is_valid_json "$api_response"; then echo "ERROR:API_INVALID_RESPONSE"; return; fi
        local matching_filename; matching_filename=$(echo "$api_response" | jq -r --arg filter "$filter" '.[0].assets.links[] | select(.name | test($filter; "i")) | .name' | head -n 1)
        if [ -z "$matching_filename" ]; then echo "ERROR:NO_ASSET_FOUND"; else echo "$matching_filename"; fi
    elif [ "$type" == "github_ci" ]; then
        local page_content; page_content=$(curl -sL "$source")
        local direct_download_url; direct_download_url=$(echo "$page_content" | grep -o 'https://nightly.link/[^"]*\.zip' | head -n 1)
        if [ -z "$direct_download_url" ]; then echo "ERROR:CI_LINK_NOT_FOUND"; else basename "$direct_download_url"; fi
    fi
}

check_module_link() {
    local module_name=$1
    if [ -z "$module_name" ]; then error "Lütfen kontrol edilecek bir modül adı belirtin. Örnek: mis check ZygiskNext"; fi
    local module_json; module_json=$(jq --arg name "$module_name" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    if [ -z "$module_json" ]; then error "'$module_name' modülü yapılandırmada bulunamadı."; fi

    info "'$module_name' modülü için link kontrol ediliyor..."
    local remote_file; remote_file=$(get_remote_filename "$module_name")

    if [[ "$remote_file" == "ERROR"* ]]; then
        error "Uzak dosya adı alınamadı. Hata: $remote_file"
    else
        info "BULUNAN UZAK DOSYA ADI: $remote_file"
    fi
}

check_all_updates() {
    info "Tüm modüller için güncellemeler kontrol ediliyor..."
    mapfile -t modules < <(jq -r '.modules[].name' "$MODULES_FILE")
    if [ ${#modules[@]} -eq 0 ]; then warn "Kontrol edilecek modül bulunamadı."; return; fi

    declare -a results_module results_cached results_remote results_status
    local updates_found=0

    for module_name in "${modules[@]}"; do
        echo -e " -> ${BLUE}Kontrol ediliyor:${NC} $module_name"
        local remote_file; remote_file=$(get_remote_filename "$module_name")
        local cached_file; cached_file=$(jq -r --arg mod "$module_name" '.[$mod] // "-"' "$CACHE_MANIFEST")

        if [[ "$cached_file" != "-" && ! -f "$CACHE_DIR/$cached_file" ]]; then
            warn "Manifest'te listelenen '$cached_file' dosyası önbellekte bulunamadı, manifest güncelleniyor."
            cached_file="-"
            jq --arg mod "$module_name" 'del(.[$mod])' "$CACHE_MANIFEST" > tmp.$$.json && mv tmp.$$.json "$CACHE_MANIFEST"
        fi

        results_module+=("$module_name")
        results_cached+=("$cached_file")
        results_remote+=("$remote_file")

        if [[ "$remote_file" == "ERROR"* ]]; then
            results_status+=("HATA")
        elif [ "$cached_file" == "$remote_file" ]; then
            results_status+=("GÜNCEL")
        elif [ "$cached_file" == "-" ]; then
            results_status+=("İNDİRİLEBİLİR")
            updates_found=1
        else
            results_status+=("GÜNCELLEME")
            updates_found=1
        fi
    done

    info "Güncelleme Kontrolü Sonuçları:"
    local max_cached_len=10 max_remote_len=10
    for file in "${results_cached[@]}"; do (( ${#file} > max_cached_len )) && max_cached_len=${#file}; done
    for file in "${results_remote[@]}"; do (( ${#file} > max_remote_len )) && max_remote_len=${#file}; done

    printf "\n${BLUE}%-15s %-${max_cached_len}s    %-${max_remote_len}s${NC}\n" "MODÜL" "ÖNBELLEKTEKİ SÜRÜM" "EN SON SÜRÜM"
    printf "%.s" $(seq 1 $(($max_cached_len + $max_remote_len + 25))) | tr ' ' '─'; echo

    for i in "${!results_module[@]}"; do
        local mod="${results_module[$i]}"; local cache="${results_cached[$i]}"; local remote="${results_remote[$i]}"; local status="${results_status[$i]}"; local line
        case "$status" in
            "GÜNCEL") line=$(printf "%-15s %-${max_cached_len}s | %s" "$mod" "$cache" "Güncel"); echo -e "${GREEN}$line${NC}";;
            "GÜNCELLEME") line=$(printf "%-15s %-${max_cached_len}s > %-${max_remote_len}s" "$mod" "$cache" "$remote"); echo -e "${YELLOW}$line${NC}";;
            "İNDİRİLEBİLİR") line=$(printf "%-15s %-${max_cached_len}s | %-${max_remote_len}s" "$mod" "Yok" "$remote"); echo -e "${YELLOW}$line${NC}";;
            "HATA") line=$(printf "%-15s %-${max_cached_len}s | %s" "$mod" "$cache" "Uzak sürüm kontrol edilemedi."); echo -e "${RED}$line${NC}";;
        esac
    done

    echo; if [ "$updates_found" -eq 0 ]; then info "Tüm modüller güncel."; else warn "Bazı modüller için güncellemeler veya yeni sürümler mevcut."; fi
}

# --- Senkronizasyon Fonksiyonları ---

sync_modules() {
    info "Aktif modüllerin önbellekleri en son sürümlerle senkronize ediliyor..."
    mapfile -t modules_to_sync < <(jq -r '.modules[] | select(.enabled == true) | .name' "$MODULES_FILE")

    if [ ${#modules_to_sync[@]} -eq 0 ]; then
        warn "Senkronize edilecek aktif modül bulunamadı."
        return
    fi

    info "Aktif modüller paralel olarak kontrol ediliyor/indiriliyor (Maksimum $MAX_JOBS iş)..."
    RESULTS_DIR=$(mktemp -d)
    local job_count=0

    for module_name in "${modules_to_sync[@]}"; do
        process_single_download "$module_name" > "$RESULTS_DIR/$module_name.result" &
        ((job_count++))
        if ((job_count >= MAX_JOBS)); then
            wait -n
            ((job_count--))
        fi
    done
    wait

    info "Senkronizasyon sonuçları işleniyor..."
    local has_errors=0
    for module_name in "${modules_to_sync[@]}"; do
        local result_file="$RESULTS_DIR/$module_name.result"
        if [ -f "$result_file" ]; then
            local result
            result=$(cat "$result_file")
            if [[ "$result" == "ERROR"* ]]; then
                warn "'$module_name' senkronize edilemedi. Hata: ${result}"
                has_errors=1
            fi
        fi
    done

    if [ "$has_errors" -eq 0 ]; then
        info "Tüm aktif modüllerin önbellekleri başarıyla senkronize edildi."
    else
        warn "Bazı modüller senkronize edilirken hatalarla karşılaşıldı."
    fi
}

process_single_download() {
    local module_name=$1
    local remote_file; remote_file=$(get_remote_filename "$module_name")
    if [[ "$remote_file" == "ERROR"* ]]; then echo "$remote_file"; return 1; fi

    local cached_file; cached_file=$(jq -r --arg mod "$module_name" '.[$mod] // ""' "$CACHE_MANIFEST")

    if [[ -n "$cached_file" && "$cached_file" == "$remote_file" && -f "$CACHE_DIR/$cached_file" ]]; then
        echo -e "${GREEN}[BİLGİ]${NC} '$module_name' güncel, indirme atlanıyor." >&2
        echo "$CACHE_DIR/$remote_file"
        return 0
    fi

    local module_json; module_json=$(jq --arg name "$module_name" '.modules[] | select(.name == $name)' "$MODULES_FILE")
    local type; type=$(jq -r '.type' <<< "$module_json")
    local source; source=$(jq -r '.source' <<< "$module_json")
    local download_url

    if [ "$type" == "github_release" ]; then
        local owner repo; owner=$(echo "$source" | cut -d'/' -f1); repo=$(echo "$source" | cut -d'/' -f2)
        local api_response; api_response=$(get_github_api "https://api.github.com/repos/$owner/$repo/releases/latest")
        download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.assets[] | select(.name == $fname) | .browser_download_url')
    elif [ "$type" == "gitlab_release" ]; then
        local encoded_source; encoded_source=$(echo "$source" | sed 's/\//%2F/g')
        local api_response; api_response=$(get_gitlab_api "https://gitlab.com/api/v4/projects/$encoded_source/releases")
        download_url=$(echo "$api_response" | jq -r --arg fname "$remote_file" '.[0].assets.links[] | select(.name == $fname) | .url' | head -n 1)
    elif [ "$type" == "github_ci" ]; then
        local page_content; page_content=$(curl -sL "$source")
        download_url=$(echo "$page_content" | grep -o 'https://nightly.link/[^"]*\.zip' | head -n 1)
    fi

    if [ -z "$download_url" ]; then echo "ERROR:DOWNLOAD_URL_NOT_FOUND"; return 1; fi

    echo -e "${GREEN}[BİLGİ]${NC} '$module_name' için yeni sürüm indiriliyor: $remote_file" >&2
    if curl -L --fail -o "$CACHE_DIR/$remote_file" "$download_url"; then
        # --- YARIŞ DURUMU DÜZELTMESİ BAŞLANGICI ---
        # Manifest dosyasını güncellemeden önce bir kilit oluşturulur ve beklenir.
        # Bu, aynı anda sadece bir işlemin dosyaya yazmasını garanti eder.
        (
            local lock_dir="$CACHE_DIR/manifest.lock"
            while ! mkdir "$lock_dir" 2>/dev/null; do
                echo -e "${YELLOW}[KİLİT]${NC} Manifest yazma işlemi için bekleniyor: $module_name" >&2
                sleep 1
            done
            
            # Kilit alındı, şimdi dosyaları güvenle yönetebiliriz.
            local current_manifest; current_manifest=$(cat "$CACHE_MANIFEST")
            local old_cached_file; old_cached_file=$(echo "$current_manifest" | jq -r --arg mod "$module_name" '.[$mod] // ""')

            # Eski bir önbellek dosyası varsa ve yeni indirilen dosyadan farklıysa, eskisini sil
            if [[ -n "$old_cached_file" && "$old_cached_file" != "$remote_file" && -f "$CACHE_DIR/$old_cached_file" ]]; then
                echo -e "${GREEN}[BİLGİ]${NC} Eski önbellek dosyası ($old_cached_file) siliniyor." >&2
                rm -f "$CACHE_DIR/$old_cached_file"
            fi

            # Manifest'i atomik olarak güncelle (önce geçici dosyaya yaz, sonra taşı)
            echo "$current_manifest" | jq --arg mod "$module_name" --arg file "$remote_file" '.[$mod] = $file' > "$CACHE_MANIFEST.tmp" && mv "$CACHE_MANIFEST.tmp" "$CACHE_MANIFEST"

            # Kilidi serbest bırak
            rmdir "$lock_dir"
        )
        # --- YARIŞ DURUMU DÜZELTMESİ SONU ---
        
        echo "$CACHE_DIR/$remote_file"
    else
        echo "ERROR:DOWNLOAD_FAILED"; rm -f "$CACHE_DIR/$remote_file"; return 1
    fi
}

# --- Ana Fonksiyon ---

main() {
    init_system
    case $1 in add|check|check-all|sync)
        if [[ "$*" == *"github"* || "$1" == "add" ]]; then
            setup_github_token
        fi
        ;;
    esac
    if [ $# -eq 0 ]; then show_help; exit 1; fi
    case $1 in
        add)           add_module ;;
        remove)        remove_module ;;
        toggle)        toggle_module ;;
        list)          list_modules ;;
        sync)          sync_modules ;;
        check)         check_module_link "$2" ;;
        check-all)     check_all_updates ;;
        clear-cache)   clear_cache ;;
        help|--help)   show_help ;;
        *)             error "Geçersiz komut: $1"; show_help ;;
    esac
}

main "$@"

